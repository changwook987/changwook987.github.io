# 5542 釘 (Nails)

## 문제

```
      *
    *   *
  *   *   *
*   *   *   *
```

이러한 모양으로 못이 박혀 있는 판에 여러 고무줄을 사용하여 삼각형 모양으로 못을 둘러쌌을 때, 고무줄에 둘러싸인 못의 개수를 구해보자.

## 풀이

<details>
<summary>imos법</summary>

구간 합을 구하는 방법인데 신기하다.

구간에 대한 덧셈을 여러 번 요구하는 문제에서 이 방법을 사용할 수 있다.

방법은 다음과 같다.

10의 길이를 가지는 배열이 있을 때 다음과 같은 구간 덧셈이 들어온다고 생각해보자.

1. 범위 0 - 9 에 1 더하기
2. 범위 0 - 5 에 2 더하기
3. 범위 3 - 7 에 5 더하기

imos법을 사용하면 이렇게 해결 할 수 있다.

1. 길이가 11인 누적 합 배열을 만든다.

| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

2. 시작 위치에 더하는 숫자만큼 더해준다.

| 3   | 0   | 0   | 5   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

3. 끝 위치 + 1에 더하는 숫자만큼 빼준다.

| 3   | 0   | 0   | 5   | 0   | 0   | -2  | 0   | -5  | 0   | -2  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

4. 모든 입력이 끝난 뒤 누적합 연산을 해준다.

| 3   | 3   | 3   | 8   | 8   | 8   | 6   | 6   | 1   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

</details>

이 문제는 imos법을 삼각형 안에서 사용하는 방법을 찾으면 그대로 사용하면 된다.

### 입력

| 1   | -1  |     |     |     |
| --- | --- | --- | --- | --- |
|     |     |     |     |     |
| -1  |     |     | 1   |     |
|     | 1   |     | -1  |     |
|     |     |     |     |     |

### 좌 -> 우

| 1   |     |     |     |     |
| --- | --- | --- | --- | --- |
|     |     |     |     |     |
| -1  | -1  | -1  | 0   |     |
|     | 1   | 1   | 0   |     |
|     |     |     |     |     |

### 상 -> 하

| 1   |     |     |     |     |
| --- | --- | --- | --- | --- |
| 1   |     |     |     |     |
| 0   | -1  | -1  |     |     |
|     | 0   | 0   |     |     |
|     |     |     |     |     |

### 좌상 -> 우하

| 1   |     |     |     |     |
| --- | --- | --- | --- | --- |
| 1   | 1   |     |     |     |
|     | 0   | 0   |     |     |
|     |     |     |     |     |
|     |     |     |     |     |

<details open>
<summary>kotlin</summary>

```kotlin
import java.io.StreamTokenizer

val tk = StreamTokenizer(System.`in`)

fun nextInt(): Int {
    tk.nextToken()
    return tk.nval.toInt()
}

fun main() {
    val n = nextInt()
    val m = nextInt()
    val arr = Array(n + 3) { IntArray(n + 3) }
    for (z in 0..<m) {
        val y = nextInt() - 1
        val x = nextInt() - 1
        val d = nextInt()
        arr[y][x]++
        arr[y][x + 1]--
        arr[y + d + 1][x]--
        arr[y + d + 1][x + d + 2]++
        arr[y + d + 2][x + 1]++
        arr[y + d + 2][x + d + 2]--
    }
    for (i in arr.indices) // 왼쪽에서 오른쪽으로
        for (j in 0..<arr.size - 1)
            arr[i][j + 1] += arr[i][j]
    for (i in 0..<arr.size - 1) // 위쪽에서 아래쪽으로
        for (j in arr.indices)
            arr[i + 1][j] += arr[i][j]
    for (i in 0..<arr.size - 1) { // 대각선 아래로
        var x = 0
        var y = i
        while (y < arr.size - 1) {
            arr[y + 1][x + 1] += arr[y][x]
            x++; y++
        }
    }
    println(arr.sumOf { it.sumOf { if (it > 0) 1L else 0L } })
}
```

</details>
