# 1160 Random Number Generator

## 문제

홍준이는 통계학을 공부하다가 ‘무작위 추출’의 매력에 푹 빠졌고, 난수 발생기를 이용해 직접 ‘무작위 추출’을 한다. 홍준이는 일차 점화식으로 생성되는 수열을 이용한 난수 발생기가 적당하다고 생각했다. 수열을 만들기 위해서는 음이 아닌 정수 $m$, $a$, $c$, $X_0$이 필요하다. 수열 $X_n$의 점화식은 다음과 같다:

$$
X_{n+1} = (aX_n + c) \mod m
$$

"A mod m"이라는 말은 A를 m으로 나눈 나머지를 뜻한다.

최종적으로, Xn을 양의 정수 g로 나눈 나머지가 난수로 사용한다. 따라서 생성된 난수는 0, 1, …, g-1사이의 값을 가지게 될 것이다.

착한 명우는, 친구 홍준이의 속마음을 읽고, 난수 발생기를 만들어주려고 한다. 명우를 도와 홍준이에게 줄 난수 발생기 프로그램을 작성하시오.

## 풀이

만약 $n=4$ 일 경우

$\begin{aligned}
X_4
&= a(a(a(a\cdot X_0+c)+c)+c)+c \\
&= a^4X_0+a^3c+a^2c+ac+c \\
&= a^4X_0+\sum_{i=0}^{3}a^ic \\
&= a^4X_0+c\sum_{i=0}^{3}a^i 
\end{aligned}$

이렇게 $\sum\limits_{i=0}^{n}a^i$ 을 빠르게 계산하는 문제로 바꿀 수 있다.

$\sum\limits_{i=0}^{n}a^i$ 는 행렬을 이용해 빠르게 계산할 수 있다.

$$
\begin{bmatrix}
a^0 \\
a^1 + a^0 \\
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 \\
1 & a \\
\end{bmatrix}
\cdot
\begin{bmatrix}
a^0 \\
a^0 \\
\end{bmatrix}
$$

<details>
<summary>kotlin</summary>

```kotlin
import java.math.BigInteger
import java.util.StringTokenizer

var P: BigInteger = BigInteger.ZERO

infix fun Long.times(other: Long): Long =
    (toBigInteger() * other.toBigInteger() % P).toLong()

infix fun Long.plus(other: Long): Long =
    ((toBigInteger() + other.toBigInteger()) % P).toLong()

infix fun Long.minus(other: Long): Long =
    ((toBigInteger() + P - other.toBigInteger()) % P).toLong()

infix fun Long.power(exp: Long): Long {
    var p = this
    var r = 1L
    var e = exp
    while (e > 0) {
        if (e and 1 > 0) r = p times r
        p = p times p
        e = e shr 1
    }
    return r
}

typealias Matrix = Array<LongArray>

operator fun Matrix.times(other: Matrix): Matrix {
    val y = this.size
    val x = other.firstOrNull()?.size ?: 0
    val matrix = Matrix(y) { LongArray(x) }
    for (i in 0 until y)
        for (j in 0 until x)
            for (k in other.indices)
                matrix[i][j] = matrix[i][j] plus (this[i][k] times other[k][j])
    return matrix
}

infix fun Matrix.power(ex: Long): Matrix {
    var ret = Array(size) { y -> LongArray(size) { x -> if (x == y) 1 else 0 } }
    var piv = this
    var exp = ex
    while (exp > 0) {
        if (exp and 1 > 0) ret *= piv
        piv *= piv
        exp = exp shr 1
    }
    return ret
}

fun main() {
    val tk = StringTokenizer(readln())
    P = tk.nextToken().toBigInteger()
    val a = tk.nextToken().toLong()
    val c = tk.nextToken().toLong()
    val x = tk.nextToken().toLong()
    val n = tk.nextToken().toLong()
    val g = tk.nextToken().toInt()
    val mat = arrayOf(
        longArrayOf(1, 0),
        longArrayOf(1, a),
    ) power n - 1
    val res = ((a power n) times x) plus (c times (mat[1][0] plus mat[1][1]))
    println(res % g)
}
```

</details>
