# 02 시작하기

## 연습문제 1

1. 삽입 정렬 과정
    
    | 31 | 41 | 59 |`26`| 41 | 58 |
    |:--:|:--:|:--:|:--:|:--:|:--:|
    |:arrow_up:|:arrow_left:|:arrow_left:|:arrow_left:| | |

    26을 왼쪽 값과 비교해 더 작은 값이 없을 때 까지 자리를 바꾼다.

    | 26 | 31 | 41 | 59 |`41`| 58 |
    |:--:|:--:|:--:|:--:|:--:|:--:|
    | | | |:arrow_up:|:arrow_left:| |

    41을 왼쪽 값과 비교해 더 작은 값이 없을 때 까지 자리를 바꾼다.

    | 26 | 31 | 41 | 41 | 59 |`58`|
    |:--:|:--:|:--:|:--:|:--:|:--:|
    | | | | |:arrow_up:|:arrow_left:|

    58을 왼쪽 값과 비교해 더 작은 값이 없을 때 까지 자리를 바꾼다.

    | 26 | 31 | 41 | 41 | 58 | 59 |
    |:--:|:--:|:--:|:--:|:--:|:--:|

    종료
2. 오름차순 => 내림차순 번경

    ```txt{6}
    INSERTION-SORT(A)
        for j = 2 to A.length
            key = A[j]
            // A[j]를 정렬된 배열 A[1..j - 1]에 삽입한다.
            i = j - 1
            while 0 < i and A[i] < key
                A[i + 1] = A[i]
                i = i - 1
            A[i + 1] = key
    ```

    A[i] 와 key를 비교하는 조건을 반전시키면 된다.

3. 선형 검색 알고리즘을 작성해보자.
    ```rust{txt}
    fn linear_search(arr: &[i32], v: i32) -> Option<usize> {
        let mut res = None;
        for i in 0..arr.len() {
            if arr[i] == v {
                res = Some(i);
            }
        }
        res
    }
    ```

    **초기조건:**
        루프가 시작할 때 `i` 값은 0이므로 부분 배열 `&arr[0..i]` 은 길이 0의 배열이 되고, 따라서 `&arr[0..i]` 에는 검사하지 않은 원소가 존재하지 않는다.

    **유지조건:**
        매 루프마다 `arr[i]` 를 검사한다. 만약 `arr[i]` 가 `v` 라면 `res` 값을 `i` 로 업데이트 한다. 매 루프마다 `arr[i]` 에 대해 검사하므로 `&arr[0..i]` 에는 검사하지 않은 원소가 존재하지 않는다.

    **종료조건:**
        루프가 종료되는 시점에 `i` 값은 `arr.len` 이고 따라서 `&arr[0..i]` 는 전체 배열이 된다. 따라서 모든 배열의 원소에 대해 검사를 완료 하였다. 전체 배열에 대해 검사를 수행하였으므로 `res` 는 `v` 가 존재하면 가장 마지막 `v` 의 인덱스가 될 것이고, 존재하지 않는다면 `None` 값이 된다.
    

4. 이진수 덧셈을 구현해 보자.

    이진수를 저장하는 방법을 1의 자리는 1번 인덱스, 2의 자리는 2번 인덱스 4의 자리는 3번 인덱스 순으로 저장한다고 가정했을 때, 다음과 같은 코드로 두 정수의 합을 구할 수 있다.

    ```rs
    fn binary_add(a: &[u8], b: &[u8]) -> Vec[u8] {
        let n = a.len();
        let mut c = vec![0; n + 1];
        let mut carry = 0;
        for i in 0..n {
            if a[i] == b[i] {  // 0 0 또는 1 1
                c[i] = carry;
                carry = a[i];  // 1 1 일 경우 올림 발생
            } else {           // 0 1 또는 1 0
                if carry = 1 {
                    c[i] = 0;  
                } else {
                    c[i] = 1;
                }
            }
        }
        c
    }
    ```

## 연습문제 2

1. $\Theta$ 표기법

    $\Theta$ 표기법에서는 차수가 낮은 항과 차수가 가장 높은 항의 상수계수를 무시하므로 $\Theta(n^3)$ 이 된다.
    

2. 선택 정렬을 구현해 보자

    ```rs
    fn selection_sort(arr: &mut [i32]) {
        for i in 0..arr.len() - 1 {
            let mut min_idx = i;
            // find i-th min value
            for j in i + 1..arr.len() {
                if arr[min_idx] > arr[j] {
                    min_idx = j;
                }
            }
            arr.swap(min_idx, i);
        }
    }
    ```

    선택 정렬이 유지하는 루프 불변성은 `&arr[0..i]` 의 각 인덱스 `i` 에는 `i`번째로 작은 원소가 들어 있다는 것이다.

    `n` 개를 바꿀 때 까지 수행하지 않고 `n - 1` 까지 바꾸면 되는 이유는 `n - 1` 까지 반복하면 `arr[n]` 에는 제일 큰 수가 이미 자리하고 있기 때문이다. 왜냐하면 루프 불변성을 유지하기 위해 `arr[i]` 에는 `i` 번째로 작은 원소가 들어가 있기 때문이다.

    선택 정렬의 최선의 경우, 최악의 경우 모두 동일하게 $\Theta(n^2)$ 의 수행시간을 가진다.

3. 선형 검색 심화

    위에서 작성한 선형 검색 알고리즘은 항상 수열의 길이 만큼 반복하므로 항상 `수열의 길이`번 조사하게 된다. 따라서 최선, 평균, 최악의 경우 모두 $\Theta(n)$ 의 수행시간을 갖는다.

4. 최선의 경우에 알고리즘이 좋은 수행 시간을 갖게 하려면 어떻게 바꿔야 하는가?

    최선의 경우는 항상 찾는 원소가 첫 번째 원소인 경우이다. 만약 알고리즘이 일치하는 원소를 발견하면 바로 반환하는 알고리즘이라면 $\Theta(1)$ 의 수행시간을 가지게 된다.
    

## 연습문제 3

1. 병합 정렬 과정

    ![02.3.1](pictures/02.3.1.png)

    

2. merge 함수를 경계값을 사용하지 않고 구현하시오

    ```
    MERGE(A, p, q, r)
        n1 = q - p + 1
        n2 = r - q

        배열 L[1..n1]과 R[1..n2]를 생성한다.

        for i = 1 to n1
            L[i] = A[p + i - 1]
        
        for j = 1 to n2
            L[j] = A[q + j]
        
        i = 1
        j = 1
        k = p

        while i <= n1 and j <= n2
            if L[i] <= R[j]
                A[k] = L[i]
                i += 1
            else
                A[k] = R[j]
                j += 1
            k += 1
        
        while i <= n1
            A[k] = L[i]
            i += 1
            k += 1
        
        while j <= n2
            A[k] = R[j]
            j += 1
            k += 1
    ```

3. $n$ 이 2의 거듭제곱일 때 수학적 귀납법을 이용해 다음 점화식의 해가 $T(n) = n \log_2 n$ 임을 보여라.

    $$
    T(n) = \begin{cases}
            2           &  n = 2 \\
            2T(n/2) + n &  n = 2^k, k \gt 1 \\
            \end{cases}
    $$

    $$
    \begin{aligned}
    T(2) &= 2 &= 2 \log_2 2 &= 2 \log_2 2 \\
    T(4) &= 2 T(2) + 4 &= 4 \log_2 2 + 4 \log_2 2 &= 4 \log_2 4 \\
    T(8) &= 2 T(4) + 8 &= 8 \log_2 4 + 8 \log_2 2 &= 8 \log_2 8 \\
    T(n) &= 2 T(n/2) + n &= n \log_2(n/2) + n \log_2 2 &= n \log_2 n \\
    \end{aligned}
    $$
    