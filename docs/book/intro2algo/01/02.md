# 02 시작하기

## 연습문제 1

### 1번

| 31 | 41 | 59 |`26`| 41 | 58 |
|:--:|:--:|:--:|:--:|:--:|:--:|
|:arrow_up:|:arrow_left:|:arrow_left:|:arrow_left:| | |

26을 왼쪽 값과 비교해 더 작은 값이 없을 때 까지 자리를 바꾼다.

| 26 | 31 | 41 | 59 |`41`| 58 |
|:--:|:--:|:--:|:--:|:--:|:--:|
| | | |:arrow_up:|:arrow_left:| |

41을 왼쪽 값과 비교해 더 작은 값이 없을 때 까지 자리를 바꾼다.

| 26 | 31 | 41 | 41 | 59 |`58`|
|:--:|:--:|:--:|:--:|:--:|:--:|
| | | | |:arrow_up:|:arrow_left:|

58을 왼쪽 값과 비교해 더 작은 값이 없을 때 까지 자리를 바꾼다.

| 26 | 31 | 41 | 41 | 58 | 59 |
|:--:|:--:|:--:|:--:|:--:|:--:|

종료

### 2번
```txt{6}
INSERTION-SORT(A)
    for j = 2 to A.length
        key = A[j]
        // A[j]를 정렬된 배열 A[1..j - 1]에 삽입한다.
        i = j - 1
        while 0 < i and A[i] < key
            A[i + 1] = A[i]
            i = i - 1
        A[i + 1] = key
```

::: info
A[i] 와 key를 비교하는 조건을 반전시키면 된다.
:::

### 3번
```rust{txt}
fn linear_search(arr: &[i32], v: i32) -> Option<usize> {
    let mut res = None;
    for i in 0..arr.len() {
        if arr[i] == v {
            res = Some(i);
        }
    }
    res
}
```

**초기조건:**
    루프가 시작할 때 `i` 값은 0이므로 부분 배열 `&arr[0..i]` 은 길이 0의 배열이 되고, 따라서 `&arr[0..i]` 에는 검사하지 않은 원소가 존재하지 않는다.

**유지조건:**
    매 루프마다 `arr[i]` 를 검사한다. 만약 `arr[i]` 가 `v` 라면 `res` 값을 `i` 로 업데이트 한다. 매 루프마다 `arr[i]` 에 대해 검사하므로 `&arr[0..i]` 에는 검사하지 않은 원소가 존재하지 않는다.

**종료조건:**
    루프가 종료되는 시점에 `i` 값은 `arr.len` 이고 따라서 `&arr[0..i]` 는 전체 배열이 된다. 따라서 모든 배열의 원소에 대해 검사를 완료 하였다. 전체 배열에 대해 검사를 수행하였으므로 `res` 는 `v` 가 존재하면 가장 마지막 `v` 의 인덱스가 될 것이고, 존재하지 않는다면 `None` 값이 된다.
    

### 4번

이진수를 저장하는 방법을 1의 자리는 1번 인덱스, 2의 자리는 2번 인덱스 4의 자리는 3번 인덱스 순으로 저장한다고 가정했을 때, 다음과 같은 코드로 두 정수의 합을 구할 수 있다.

```rs
fn binary_add(a: &[u8], b: &[u8]) -> Vec[u8] {
    let n = a.len();
    let mut c = vec![0; n + 1];
    let mut carry = 0;
    for i in 0..n {
        if a[i] == b[i] {  // 0 0 또는 1 1
            c[i] = carry;
            carry = a[i];  // 1 1 일 경우 올림 발생
        } else {           // 0 1 또는 1 0
            if carry = 1 {
                c[i] = 0;  
            } else {
                c[i] = 1;
            }
        }
    }
    c
}
```

## 연습문제 2

### 1번

$\Theta$ 표기법에서는 차수가 낮은 항과 차수가 가장 높은 항의 상수계수를 무시하므로 $\Theta(n^3)$ 이 된다.
    

### 2번

```rs
fn selection_sort(arr: &mut [i32]) {
    for i in 0..arr.len() - 1 {
        let mut min_idx = i;
        // find i-th min value
        for j in i + 1..arr.len() {
            if arr[min_idx] > arr[j] {
                min_idx = j;
            }
        }
        arr.swap(min_idx, i);
    }
}
```

선택 정렬이 유지하는 루프 불변성은 `&arr[0..i]` 의 각 인덱스 `i` 에는 `i`번째로 작은 원소가 들어 있다는 것이다.

`n` 개를 바꿀 때 까지 수행하지 않고 `n - 1` 까지 바꾸면 되는 이유는 `n - 1` 까지 반복하면 `arr[n]` 에는 제일 큰 수가 이미 자리하고 있기 때문이다. 왜냐하면 루프 불변성을 유지하기 위해 `arr[i]` 에는 `i` 번째로 작은 원소가 들어가 있기 때문이다.

선택 정렬의 최선의 경우, 최악의 경우 모두 동일하게 $\Theta(n^2)$ 의 수행시간을 가진다.

### 3번

위에서 작성한 선형 검색 알고리즘은 항상 수열의 길이 만큼 반복하므로 항상 `수열의 길이`번 조사하게 된다. 따라서 최선, 평균, 최악의 경우 모두 $\Theta(n)$ 의 수행시간을 갖는다.

### 4번

최선의 경우는 항상 찾는 원소가 첫 번째 원소인 경우이다. 만약 알고리즘이 일치하는 원소를 발견하면 바로 반환하는 알고리즘이라면 $\Theta(1)$ 의 수행시간을 가지게 된다.
    

## 연습문제 3

### 1번

![02.3.1](pictures/02.3.1.png)

    

### 2번

```
MERGE(A, p, q, r)
    n1 = q - p + 1
    n2 = r - q

    배열 L[1..n1]과 R[1..n2]를 생성한다.

    for i = 1 to n1
        L[i] = A[p + i - 1]
    
    for j = 1 to n2
        L[j] = A[q + j]
    
    i = 1
    j = 1
    k = p

    while i <= n1 and j <= n2
        if L[i] <= R[j]
            A[k] = L[i]
            i += 1
        else
            A[k] = R[j]
            j += 1
        k += 1
    
    while i <= n1
        A[k] = L[i]
        i += 1
        k += 1
    
    while j <= n2
        A[k] = R[j]
        j += 1
        k += 1
```

### 3번

$$
T(n) = \begin{cases}
        2           &  n = 2 \\
        2T(n/2) + n &  n = 2^k, k \gt 1 \\
        \end{cases}
$$

$$
\begin{aligned}
T(2) &= 2 &= 2 \log_2 2 &= 2 \log_2 2 \\
T(4) &= 2 T(2) + 4 &= 4 \log_2 2 + 4 \log_2 2 &= 4 \log_2 4 \\
T(8) &= 2 T(4) + 8 &= 8 \log_2 4 + 8 \log_2 2 &= 8 \log_2 8 \\
T(n) &= 2 T(n/2) + n &= n \log_2(n/2) + n \log_2 2 &= n \log_2 n \\
\end{aligned}
$$

### 4번

```rs
fn binary_search(arr: &[i32], v: i32) -> Option<usize> {
    let mut l = 0;
    let mut r = arr.len() - 1;
    while l < r {
        let m = (l + r) / 2;
        if arr[m] < v {
            l = m + 1;
        } else if arr[m] > v {
            r = m -= 1;
        } else {
            return m;
        }
    }
    None
}
```

최악의 경우 모든 검색에서 실패하여 다음 루프를 돌아야 한다. 따라서 배열의 빈 배열이 될 때 까지 절반의 길이의 배열에 대해 검색을 한다고 할 수 있다. 매 루프마다 2번의 검색을 하므로 총 $2 \log_2 n$ 번의 검색을 하게 된다. 따라서 $\Theta(\log_2 n)$ 의 수행시간을 갖게 된다.

### 6번

삽입 정렬에서 삽입할 위치를 찾는 부분을 이진 검색으로 찾을 수 있다. 하지만 찾은 부분에 삽입하는 과정에서 다시 $n$ 번의 시간이 걸리기 때문에 수행시간을 개선할 수는 없을 것 같다.

### 7번

```rs
fn solution(arr: &mut [i32], x: i32) -> bool {
    merge_sort(arr); // 정렬 n log n
    for i in 0..arr.len() {
        if binary_search(&arr, x - arr[i]) { // 이분탐색 log n
            return true
        }
    }
    return false
}
```

## 종합 문제

### 1번

#### a

크기가 $k$ 인 리스트의 삽입 정렬의 수행시간 = $\Theta(k^2)$ 곱하기 $n / k$ 는 $\Theta(nk)$

#### b

병합하는데 걸리는 시간은 재귀 깊이 당 n 이고 재귀 깊이는 $\log_2 (n / k)$ 이므로 $\Theta(n \log_2 (n / k))$ 이다.

#### c

$k = log_2(n)$

#### d

큰 n의 값에 대해 다양한 k의 값을 사용해 보면서 시간을 측정해서 가장 좋은 k값을 사용한다.

### 2번

#### a

:thinking:

#### b

각 반복 시작시에 A[i..n]의 최솟값은 A[i..j]에 있다.

**초기조건:** 루프의 시작은 j = A.len. 따라서 A[i..n]의 최솟값은 A[i..n]에 있으므로 성립한다.

**유지조건:** 각 루프마다 A[j] < A[j - 1] 일 경우 둘의 위치를 바꾼다. A[j] >= A[j - 1] 이므로 A[j]는 최솟값이 아니다. 그러므로 다음 A[i..n] 의 최솟값은 A[i..j - 1]안에 있다.

**종료조건:** 루프가 종료되면 j = i 이므로 A[i..n]의 최솟값은 A[i]에 있게 된다.

#### c

각 A[1..i - 1] 는 정렬된 상태이다.

**초기조건:** 루프의 시작은 i = 1. 따라서 길이가 0인 리스트는 정렬된 상태이므로 루프 불변식을 성립한다.

**유지조건:** 각 루프마다 A[i..n]의 최솟값은 A[i]이므로 A[i]는 전체 리스트에서 i번째로 작은 값이 된다. 그러므로 루프 불변식을 성립한다.

**종료조건:** 루프가 종료되는 시점의 i는 n + 1이므로 A[1..n] 는 정렬된 상태이다.

### 3번

#### a

단순히 n downto 0이므로 $\Theta(n)$ 이다.

#### b

```
sum = 0

for i = 0 to n
    res = a_i
    for j in 0 to i
        res *= x
    sum += res
```

이 알고리즘의 수행시간은 $\Theta(n^2)$ 이다.

Horner 공식과 비교하면 느리다.

#### c

:thinking:

#### d

:thinking:

### 4번

#### a

(1, 5), (2, 5), (3, 4), (3, 5), (4, 5)

#### b

내림차순 순열일 때.

$n\choose 2$ 개의 역위를 가진다.

#### c

역위가 아니면 그 위치가 올바른 위치이고 삽입정렬은 아무 것도 하지 않아도 되기 때문에 역위 개수가 증가할수록 수행시간이 늘어난다.

#### d

병합할 때 left 보다 right를 먼저 삽입할 때 역위를 세면 된다.

```c++
lint merge_sort(vector<int>& arr,
                vector<int>& tmp,
                int l, int r) {
    if (l == r) return 0;
    int m = (l + r) >> 1;
    lint cnt = merge_sort(arr, tmp, l, m) + merge_sort(arr, tmp, m + 1, r);
    int i = l, j = m + 1;
    int k = 0;
    while (i <= m && j <= r) {
        if (arr[i] == arr[j]) {
            tmp[k++] = arr[i++];
        } else if (arr[i] > arr[j]) {
            cnt += m - i + 1;
            tmp[k++] = arr[j++];
        } else {
            tmp[k++] = arr[i++];
        }
    }
    while (i <= m) tmp[k++] = arr[i++];
    while (j <= r) tmp[k++] = arr[j++];
    for (int i = 0; i < k; i++)
        arr[l + i] = tmp[i];
    return cnt;
}
```

